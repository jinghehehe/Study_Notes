c++代码片段
一.暴力递归
class Solution {
public:
    bool isMatch(string s, string p) {
        // 暴力递归
        if (p.empty()) return s.empty();
        bool first = !s.empty() && (p[0] == s[0] || p[0] == '.');
        if (p.length() >= 2 && p[1] == '*') 
        {
            //             *匹配为空        ||     *匹配为非空  
            return isMatch(s, p.substr(2)) || (first && isMatch(s.substr(1), p));
        } 
        else 
        {
            return first && isMatch(s.substr(1), p.substr(1));
        }
    }
};

二.备忘录递归
class Solution {
public:
    bool isMatch(string s, string p) {
        slen = s.size();
        plen = p.size();
        return dp(0, 0, s, p);
    }
    bool dp(int i, int j, const string &s, const string &p){
	//备忘录递归
        bool ans;
        if(memo[i][j])
            return memo[i][j];
        if(j == plen)
            return i == slen;
        bool first = (i < slen) && (p[j] == s[i] || p[j] == '.');
        if((j <= plen - 2) && p[j + 1] == '*')
 	    //             *匹配为空        ||     *匹配为非空  
            ans = dp(i, j + 2, s, p) || first && dp(i + 1, j, s, p);
        else
            ans = first && dp(i + 1, j + 1, s, p);
        memo[i][j] = ans;
        return ans;
    }
private:
    bool memo[1000][1000];//备忘录
    int slen, plen;
};

三.dp动态规划
